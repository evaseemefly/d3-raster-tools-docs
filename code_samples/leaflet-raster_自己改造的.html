<!DOCTYPE html>
<html>
  <head>
    <title>GeoJSON tutorial - Leaflet</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>
    <script src="geotiff.min.js"></script>
    <script src="raster-marching-squares.min.js"></script>

    <style>
      #map {
        width: 680px;
        height: 500px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      var xhr = new XMLHttpRequest();
      // 读取一下 西北太风场的数据测试一下 test_all_fet.tiff | vardah.tiff
      xhr.open("GET", "test_all_fet.tiff", true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function (e) {
        // 下面的备注是家在测试 tiff的 vardah.tiff
        var tiff = GeoTIFF.parse(this.response);
        var image = tiff.getImage();
        // 相当于是 geotiff 本身的 宽高
        // 188
        var tiffWidth = image.getWidth();
        //137
        var tiffHeight = image.getHeight();
        // [Float32Array(25756), Float32Array(25756), Float32Array(25756), Float32Array(25756)]
        var rasters = image.readRasters();
        // i: 0
        // j: 0
        // k: 0
        // x: 69.90238016932595
        // y: 20.03206514657981
        // z: 0
        var tiepoint = image.getTiePoints()[0];
        var pixelScale = image.getFileDirectory().ModelPixelScale;
        // [对角线 左侧顶部 ,像素大小[0] ,对角线 右下 ,像素大小 [1]]
        // [69.90238016932595, 0.11718756105503093, 0, 20.03206514657981, 0, -0.11714657980456025]
        var geoTransform = [
          tiepoint.x,
          pixelScale[0],
          0,
          tiepoint.y,
          0,
          -1 * pixelScale[1],
        ];

        var pressData = new Array(tiffHeight);
        var tempData = new Array(tiffHeight);
        // var uData = new Array(tiffHeight);
        // var vData = new Array(tiffHeight);
        // var spdData = new Array(tiffHeight);
        for (var j = 0; j < tiffHeight; j++) {
          pressData[j] = new Array(tiffWidth);
          // tempData[j] = new Array(tiffWidth);
          // uData[j] = new Array(tiffWidth);
          // vData[j] = new Array(tiffWidth);
          // spdData[j] = new Array(tiffWidth);
          for (var i = 0; i < tiffWidth; i++) {
            pressData[j][i] = rasters[0][i + j * tiffWidth];
            // tempData[j][i] = rasters[1][i + j*tiffWidth];
            // uData[j][i] = rasters[2][i + j*tiffWidth];
            // vData[j][i] = rasters[3][i + j*tiffWidth];
            // spdData[j][i] = 1.943844492 * Math.sqrt(uData[j][i]*uData[j][i] + vData[j][i]*vData[j][i]);
          }
        }

        //Creating the color scale https://github.com/santilland/plotty/blob/master/src/plotty.js
        // 把他理解为色标 0 -> 1 即可
        // var cs_def = {
        //   positions: [
        //     0.0,
        //     0.030303030303,
        //     0.0606060606061,
        //     0.0909090909091,
        //     0.121212121212,
        //     0.151515151515,
        //     0.181818181818,
        //     0.212121212121,
        //     0.242424242424,
        //     0.272727272727,
        //     0.30303030303,
        //     0.333333333333,
        //     0.363636363636,
        //     0.393939393939,
        //     0.424242424242,
        //     0.454545454545,
        //     0.484848484848,
        //     0.515151515152,
        //     0.545454545455,
        //     0.575757575758,
        //     0.606060606061,
        //     0.636363636364,
        //     0.666666666667,
        //     0.69696969697,
        //     0.727272727273,
        //     0.757575757576,
        //     0.787878787879,
        //     0.818181818182,
        //     0.848484848485,
        //     0.878787878788,
        //     0.909090909091,
        //     0.939393939394,
        //     0.969696969697,
        //     1.0,
        //   ],
        //   colors: [
        //     "#ffffff",
        //     "#e5e5e6",
        //     "#d1d1d1",
        //     "#bababa",
        //     "#979797",
        //     "#646464",
        //     "#1464d3",
        //     "#1e6eeb",
        //     "#2883f1",
        //     "#3c97f5",
        //     "#50a5f5",
        //     "#78b9fb",
        //     "#97d3fb",
        //     "#b5f1fb",
        //     "#e1ffff",
        //     "#0ea10e",
        //     "#1eb31e",
        //     "#36d33c",
        //     "#50ef50",
        //     "#78f572",
        //     "#97f58d",
        //     "#b5fbab",
        //     "#c9ffbf",
        //     "#ffe978",
        //     "#ffc13c",
        //     "#ffa100",
        //     "#ff6000",
        //     "#ff3200",
        //     "#e11400",
        //     "#c10000",
        //     "#a50000",
        //     "#643c32",
        //     "#785046",
        //     "#8d645a",
        //   ],
        // };
        var cs_def = {
          positions: [
            0.0,0.02,0.03,0.04,0.05,0.06,0.07
          ],
          colors: [
            "#1464d3",
            "#2883f1",
            "#78b9fb",
            "#b5f1fb",
            "#1eb31e",
            "#ffa100",
            "#a50000",
          ],
        };
        var scaleWidth = 256;
        var canvasColorScale = document.createElement("canvas");
        canvasColorScale.width = scaleWidth;
        canvasColorScale.height = 1;
        canvasColorScale.style.display = "none";

        document.body.appendChild(canvasColorScale);
        // 获得渲染上下文和它的绘画功能
        
        var contextColorScale = canvasColorScale.getContext("2d");

        // 定义从黑到白的渐变（从左向右），作为矩形的填充样式：
        // createLinearGradient() 方法创建线性的渐变对象。
        // 渐变可用于填充矩形、圆形、线条、文本等等。
        // 提示：请使用该对象作为 strokeStyle 或 fillStyle 属性的值。
        // 提示：请使用 addColorStop() 方法规定不同的颜色，以及在 gradient 对象中的何处定位颜色。
        // 参数值
        // 参数	描述
        // x0	渐变开始点的 x 坐标
        // y0	渐变开始点的 y 坐标
        // x1	渐变结束点的 x 坐标
        // y1	渐变结束点的 y 坐标
        // context.createLinearGradient(x0,y0,x1,y1);        
        var gradient = contextColorScale.createLinearGradient(
          0,
          0,
          scaleWidth, //256
          1
        );

        for (var i = 0; i < cs_def.colors.length; ++i) {
          gradient.addColorStop(cs_def.positions[i], cs_def.colors[i]);
        }
        
        contextColorScale.fillStyle = gradient;
        // 绘制“已填色”的矩形。默认的填充颜色是黑色
        // context.fillRect(x,y,width,height);
        // x	矩形左上角的 x 坐标
        // y	矩形左上角的 y 坐标
        // width	矩形的宽度，以像素计
        // height	矩形的高度，以像素计
        contextColorScale.fillRect(0, 0, scaleWidth, 1);

        // 返回一个ImageData对象，用来描述canvas区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。
        // ImageData ctx.getImageData(sx, sy, sw, sh);
        // sx 将要被提取的图像数据矩形区域的左上角 x 坐标。
        // sy 将要被提取的图像数据矩形区域的左上角 y 坐标。
        // sw 将要被提取的图像数据矩形区域的宽度。
        // sh 将要被提取的图像数据矩形区域的高度。
        var csImageData = contextColorScale.getImageData(
          0,
          0,
          scaleWidth - 1,
          1
        ).data;

        //Calculating the image
        // TODO:[*] 这个尺寸目前不知道是怎么确定的
        var width = 680,
          height = 500;

        var canvasRaster = document.createElement("canvas");
        canvasRaster.width = width;
        canvasRaster.height = height;
        canvasRaster.style.display = "none";

        document.body.appendChild(canvasRaster);

        var contextRaster = canvasRaster.getContext("2d");

        var id = contextRaster.createImageData(width, height);
        var data = id.data;
        var pos = 0;

        // geoTransform: [对角线 左侧顶部 ,像素大小[0] ,对角线 右下 ,像素大小 [1]]
        // invGeoTransform: (6) [-596.5, 8.533328887443975, 0, 171.00000000000006, 0, -8.536314091869649]
        // TODO:[*] invGeoTransform 何用?
        var invGeoTransform = [
          -geoTransform[0] / geoTransform[1],
          1 / geoTransform[1],
          0,
          -geoTransform[3] / geoTransform[5],
          0,
          1 / geoTransform[5],
        ];
        for (var j = 0; j < height; j++) {
          for (var i = 0; i < width; i++) {
            var pointCoordsX =
              geoTransform[0] + (i * tiffWidth * geoTransform[1]) / width;
            var pointCoordsY =
              geoTransform[3] + (j * tiffHeight * geoTransform[5]) / height;

            var px = invGeoTransform[0] + pointCoordsX * invGeoTransform[1];
            var py = invGeoTransform[3] + pointCoordsY * invGeoTransform[5];

            var value;
            if (
              Math.floor(px) >= 0 &&
              Math.ceil(px) < image.getWidth() &&
              Math.floor(py) >= 0 &&
              Math.ceil(py) < image.getHeight()
            ) {
              // Math.ceil 对数字进行向上取整
              var dist1 = (Math.ceil(px) - px) * (Math.ceil(py) - py);
              var dist2 = (px - Math.floor(px)) * (Math.ceil(py) - py);
              // Math.floor()执行向下舍入
              var dist3 = (Math.ceil(px) - px) * (py - Math.floor(py));
              var dist4 = (px - Math.floor(px)) * (py - Math.floor(py));
              if (dist1 != 0 || dist2 != 0 || dist3 != 0 || dist4 != 0) {
                value =
                  pressData[Math.floor(py)][Math.floor(px)] * dist1 +
                  pressData[Math.floor(py)][Math.ceil(px)] * dist2 +
                  pressData[Math.ceil(py)][Math.floor(px)] * dist3 +
                  pressData[Math.ceil(py)][Math.ceil(px)] * dist4;
              } else {
                value = pressData[Math.floor(py)][Math.floor(px)];
              }
            } else {
              value = -999;
            }
            // TODO:[*] 此处是干嘛的
            // Math.round()执行标准舍入
            var c = Math.round((scaleWidth - 1) * ((value - 8) / 88));
            var alpha = 200;
            if (c < 0 || c > scaleWidth - 1) {
              alpha = 0;
            }
            data[pos] = csImageData[c * 4];
            data[pos + 1] = csImageData[c * 4 + 1];
            data[pos + 2] = csImageData[c * 4 + 2];
            data[pos + 3] = alpha;
            pos = pos + 4;
          }
        }
        contextRaster.putImageData(id, 0, 0);
        var imageBounds = [
          [geoTransform[3], geoTransform[0]],
          [
            geoTransform[3] + tiffHeight * geoTransform[5],
            geoTransform[0] + tiffWidth * geoTransform[1],
          ],
        ];

        var imageLayer = L.imageOverlay(canvasRaster.toDataURL(), imageBounds, {
          opacity: 0.5,
        });

        var baseLayer = L.tileLayer(
          "https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw",
          {
            maxZoom: 18,
            attribution:
              'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
              '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
              'Imagery © <a href="http://mapbox.com">Mapbox</a>',
            id: "mapbox.light",
          }
        );

        var map = L.map("map", {
          layers: [baseLayer, imageLayer],
        }).setView([13, 81], 6);
      };
      xhr.send();
    </script>
  </body>
</html>
